<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Polygon</title>
		<meta name="author" content="Anne2440" />
		<link rel="stylesheet" href="GeometryDocStyle.css">
	</head>
	<body>
		<div id="header">
			<h1 id="topic">Polygons</h1>
			<ul id="menu">
				<li><a href="http://esri.github.io/geometry-api-java/javadoc/com/esri/core/geometry/Polygon.html" target="_blank">API Reference</a></li>
				<li><a href="https://github.com/Esri/geometry-api-java/wiki/" target="_blank">Wiki Home</a></li>
			</ul>
		</div>
		<div id="content">
			<p>A polygon is defined by a collection of rings. Each ring is a collection of contiguous line segments such
				that the start point and the end point are the same.
			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring1.jpg">
				<div class="desc">Ring</div>
			</div>
			<h2 id="boundary">Boundary and Rings</h2>
			<p>The <i>boundary</i> of a polygon is the collection of rings by which the polygon is defined. The boundary
				contains one or more outer rings and zero or more inner rings. An outer ring is oriented clockwise while
				an inner ring is oriented counterclockwise. Imagine walking clockwise along an outer ring. The area to
				your immediate right is the <i>interior</i> of the polygon and to your left is the <i>exterior</i>.

			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring2.jpg">
				<div class="desc">Outer Ring</div>
			</div>
			<p>Similarly, if you were to walk counter-clockwise along an inner ring, the area to your immediate
				right is the interior of the polygon and to your left is the exterior.
			</p>
			<div class="image240">
				<img src="Images/Polygon/Ring3.jpg">
				<div class="desc">Outer &amp; Inner Ring</div>
			</div>
			<p>It is important to understand the boundary, interior and exterior of a geometry when using the various
				operators. The relational operators, for example, rely heavily on these concepts.
			</p>
			<p>If a polygon has an inner ring, the inner ring looks like a hole. If the hole contains
				another outer ring, that outer ring looks like an island.
			</p>
			<table>
				<tr>
					<td><img src="Images/Polygon/Polygon1.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/Polygon2.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/Polygon3.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/Polygon4.jpg" class="specifics"></td>
				</tr>
				<tr>
					<td>1 outer ring, no inner rings</td>
					<td>4 outer rings, no inner rings</td>
					<td>1 outer ring, 1 inner ring</td>
					<td>2 outer rings, 1 inner ring</td>
				</tr>
			</table>

			<h2>Valid polygons</h2>
			<p>A valid polygon has the following main property:
				<li>for every polygon segment, the polygon exterior is unambiguously to the left of the segment and
					the polygon interior is unambiguously to the right of the segment.</li>
				As a result of the above property the following is also true:
				<li>segments can touch other segments only at the end points,</li>
				<li>segments have non-zero length,</li>
				<li>outer rings are clockwise and holes are counterclockwise,</li>
				<li>each polygon ring has non-zero area.</li>
				<li>order of the rings does not matter,</li>
				<li>rings can be self-tangent,</li>
				<li>rings can not overlap.</li>
			A valid polygon is said to be <i>simple</i>.
			See the <a href="Simplify.html">Simplify operator</a> for a more detailed specification
			of simple polygons. Note that a simple polygon may not be <a href="https://www.opengeospatial.org/standards/sfa"> OGC simple</a>. See the <a href="https://esri.github.io/geometry-api-java/javadoc/com/esri/core/geometry/OperatorSimplifyOGC.html">
				Simplify operator with OGC restrictions</a>.
			</p>
			<h3>Examples</h3>
			<p>
				Let's look at some examples of non-simple vs. simple polygons. The green circles are the vertices of the polygon,
				and the lavender colored area represents the interior of the polygon.
			</p>
			<table style="width:30%">
				<tr>
					<th colspan="5">Non-simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/NonSimplePolygon1.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/NonSimplePolygon2.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/NonSimplePolygon3.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/NonSimplePolygon5.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/NonSimplePolygon4.jpg" class="specifics"></td>
				</tr>
				<tr>
					<td>Self-intersection</td>
					<td>Self-intersection</td>
					<td>Dangling segment</td>
					<td>Dangling segment</td>
					<td>Overlapping rings</td>
				</tr>
			</table>
			<br /><br />
			<table style="width:30%">
				<tr>
					<th colspan="5">Simple polygons</th>
				</tr>
				<tr>
					<td><img src="Images/Polygon/SimplePolygon1.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/SimplePolygon2.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/SimplePolygon3.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/SimplePolygon5.jpg" class="specifics"></td>
					<td><img src="Images/Polygon/SimplePolygon4.jpg" class="specifics"></td>
				</tr>
				<tr>
					<td>No self-intersection</td>
					<td>Self-intersection at vertex</td>
					<td>No dangling segment</td>
					<td>No dangling segment</td>
					<td>No overlapping rings</td>
				</tr>
			</table>
			<p>When drawing a polygon, use the even-odd fill rule. The even-odd fill rule will guarantee that the polygon
				will draw correctly even if the ring orientation is not as described above for simple polygons.
			</p>
			<h3 id="JSON">JSON format</h3>
			<p>A polygon can be represented as a JSON string. A polygon in JSON format contains an array of <code>rings</code>
				and an optional <code>spatialReference</code>. A polygon can also have boolean-valued <code>hasM</code> and <code>hasZ</code> fields. The default value is false
				for both the <code>hasM</code> and <code>hasZ</code> fields.
			</p>
			<p>Each ring is represented by an array of points. Exterior rings are oriented clockwise, while interior rings
				are oriented counter-clockwise. The order of the rings is irrelevant. The first point of each ring is always the same as the last point.
				Each point in a ring is represented as an array of numbers. See the description of
				<a href="Multipoint.html#JSON">JSON multipoints</a> for details on the interpretation of the point arrays.
			</p>
			<p>An empty polygon is represented with an empty array for the <code>rings</code> field.</p>

			<h4>Syntax</h4>
			<div class="codeSample">
<pre>{
  "hasZ" : true | false,
  "hasM" : true | false,
  "rings": [
             [[&lt;x<sub>11</sub>&gt;,&lt;y<sub>11</sub>&gt;,&lt;z<sub>11</sub>&gt;,&lt;m<sub>11</sub>&gt;],[&lt;x<sub>12</sub>&gt;,&lt;y<sub>12</sub>&gt;,&lt;z<sub>12</sub>&gt;,&lt;m<sub>12</sub>&gt;], ... ,[&lt;x<sub>1j</sub>&gt;,&lt;y<sub>1j</sub>&gt;,&lt;z<sub>1j</sub>&gt;,&lt;m<sub>1j</sub>&gt;]],
             ... ,
             [[&lt;x<sub>n1</sub>&gt;,&lt;y<sub>n1</sub>&gt;,&lt;z<sub>n1</sub>&gt;,&lt;m<sub>n1</sub>&gt;],[&lt;x<sub>n2</sub>&gt;,&lt;y<sub>n2</sub>&gt;,&lt;z<sub>n2</sub>&gt;,&lt;m<sub>n2</sub>&gt;], ... ,[&lt;x<sub>nk</sub>&gt;,&lt;y<sub>nk</sub>&gt;,&lt;z<sub>nk</sub>&gt;,&lt;m<sub>nk</sub>&gt;]]
           ],
  "spatialReference" : {"wkid" : &lt;wkid&gt;}
}</pre>
			</div>
			<h4>2D Polygon</h4>
			<div class="codeSample">
<pre>{
  "rings": [
             [[6453,16815],[10653,16423],[14549,5204],[-7003,6939],[6453,16815]],
             [[914,7992],[3140,11429],[1510,10525],[914,7992]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</pre>
			</div>
			<h4>3D Polygon with Ms</h4>
			<p>Note that the third point does not have a z-value, and the second ring does not have any m-values.</p>
			<div class="codeSample">
<pre>{
  "hasZ" : true,
  "hasM" : true,
  "rings": [
             [[6453,16815,35,1],[10653,16423,36,2],[14549,5204,null,3],[-7003,6939,37,4],[6453,16815,35,1]],
             [[914,7992,30],[3140,11429,29],[1510,10525,28],[914,7992,30]]
           ],
  "spatialReference" : {"wkid" : 54004}
}
</pre>
			</div>
			<h4>Empty Polygon</h4>
			<div class="codeSample">
				<pre class="emptyGeom">{"rings": []}</pre>
			</div>
			<h2>Creating a polygon</h2>
			<p>To create a polygon, we can use the <code>Polygon</code> class methods or one of the import operators. </p>
			<p>Each of the code samples below creates a polygon with two outer rings and one inner ring.<br />
				The polygon looks like this:<br />
				<table style="margin-left:auto;margin-right:auto;width:20%">
				<tr>
					<td><img src="Images/Polygon/CreatePolygon.jpg" width="250" height="197"></td>
				</tr>
				<tr>
					<td>Create this polygon</td>
				</tr>
			</table>

			</p>
			<h3><code>Polygon</code> class methods</h3>
			<p>When using the <code>Polygon</code> class methods to create a polygon, the order in which the rings are created
				doesn't matter. What matters is the ring orientation. Remember, clockwise implies an outer ring whereas
				counter-clockwise implies an inner ring.
			</p>
			<p>To begin each ring, we call the <code>startPath</code> method and then successive calls to the
				<code>lineTo</code> method. We don't need to repeat the start point as the end point.
			</p>
			<div class="codeSample">
<pre class="classMethod">public static Polygon createPolygon1()
{
    Polygon poly = new Polygon();

    <span class="codeComment">// clockwise => outer ring</span>
    poly.startPath(0, 0);
    poly.lineTo(-0.5, 0.5);
    poly.lineTo(0, 1);
    poly.lineTo(0.5, 1);
    poly.lineTo(1, 0.5);
    poly.lineTo(0.5, 0);

    <span class="codeComment">// hole</span>
    poly.startPath(0.5, 0.2);
    poly.lineTo(0.6, 0.5);
    poly.lineTo(0.2, 0.9);
    poly.lineTo(-0.2, 0.5);
    poly.lineTo(0.1, 0.2);
    poly.lineTo(0.2, 0.3);

    <span class="codeComment">// island</span>
    poly.startPath(0.1, 0.7);
    poly.lineTo(0.3, 0.7);
    poly.lineTo(0.3, 0.4);
    poly.lineTo(0.1, 0.4);

    return poly;
}
</pre>
			</div>
			<h3>Import from JSON</h3>
			<p>As with the <code>Polygon</code> class methods, when using <code>OperatorImportFromJson</code>
				to create a polygon the order in which the rings are created doesn't matter. What matters is the
				ring orientation. Unlike the <code>Polygon</code> class methods, the start point of each ring must
				be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as before, but notice that the inner ring that forms the hole
				is given before the outer ring. This was done just to drive home the point that the order of the rings
				doesn't matter when the polygon is in JSON format.
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromJson() throws JsonParseException, IOException
{
    String jsonString = "{\"rings\":[[[0.5,0.2],[0.6,0.5],[0.2,0.9],[-0.2,0.5],[0.1,0.2],[0.2,0.3],[0.5,0.2]],"
                      + "[[0.0,0.0],[-0.5,0.5],[0.0,1.0],[0.5,1.0],[1.0,0.5],[0.5,0.0],[0.0,0.0]],"
                      + "[[0.1,0.7],[0.3,0.7],[0.3,0.4],[0.1,0.4],[0.1,0.7]]],"
                      + " \"spatialReference\":{\"wkid\":4326}}";

    MapGeometry mapGeom = OperatorImportFromJson.local().execute(Geometry.Type.Polygon, jsonString);

    return (Polygon)mapGeom.getGeometry();
}
</pre>
			</div>
			<h3>Import from GeoJSON</h3>
			<p>Unlike the <code>Polygon</code> class methods and <code>OperatorImportFromJson</code>, when using
				<code>OperatorImportFromGeoJson</code> to create a polygon the order in which the rings are given
				does matter. Within an array of rings, the outer ring is always first followed by zero or more
				inner rings. However, the order of the arrays of rings doesn't matter. The start point of each
				ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as in the previous examples.
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromGeoJson() throws JsonParseException, IOException
{
    String geoJsonString = "{\"type\":\"MultiPolygon\","
                         + "\"coordinates\":[[[[0.0,0.0],[-0.5,0.5],[0.0,1.0],[0.5,1.0],[1.0,0.5],[0.5,0.0],[0.0,0.0]],"
                         + "[[0.5,0.2],[0.6,0.5],[0.2,0.9],[-0.2,0.5],[0.1,0.2],[0.2,0.3],[0.5,0.2]]],"
                         + "[[[0.1,0.7],[0.3,0.7],[0.3,0.4],[0.1,0.4],[0.1,0.7]]]],"
                         + "\"crs\":\"EPSG:4326\"}";

    MapGeometry mapGeom = OperatorImportFromGeoJson.local().execute(GeoJsonImportFlags.geoJsonImportDefaults, Geometry.Type.Polygon, geoJsonString, null);

    return (Polygon)mapGeom.getGeometry();
}
</pre>
			</div>
			<h3>Import from WKT</h3>
			<p>As with <code>OperatorImportFromGeoJson</code>, when using <code>OperatorImportFromWkt</code>
				to create a polygon the order in which the rings are given does matter. Within an array of rings,
				the outer ring is always first followed by zero or more inner rings. However, the order of the arrays
				of rings doesn't matter. The start point of each ring must be repeated to specify the end point.
			</p>
			<p>The code shown below creates the same polygon as in the previous examples, but notice that the outer ring
				that forms the island is given first. This was done for illustrative purposes. It could have been given last,
				which probably would be more understandable to the reader.
			</p>
			<div class="codeSample">
<pre class="import">static Polygon createPolygonFromWKT() throws JsonParseException, IOException
{
    String wktString = "MULTIPOLYGON (((0.1 0.7, 0.1 0.4, 0.3 0.4, 0.3 0.7, 0.1 0.7)),"
                     + "((0 0, 0.5 0, 1 0.5, 0.5 1, 0 1, -0.5 0.5, 0 0),"
                     + "(0.5 0.2, 0.2 0.3, 0.1 0.2, -0.2 0.5, 0.2 0.9, 0.6 0.5, 0.5 0.2)))";

    Geometry geom = OperatorImportFromWkt.local().execute(WktImportFlags.wktImportDefaults, Geometry.Type.Polygon, wktString, null);

    return (Polygon)geom;
}
</pre>
			</div>
			<h2>Extracting Outer Rings</h2>
			<p>Many workflows require getting only the outer rings of a polygon.</p>
			<p>The method <code>getAllOuterRings</code> extracts all the outer rings of a polygon. The call to
			<code>OperatorSimplifyOGC</code> makes sure there are no self-intersections, all outer rings are
			clockwise, and holes are counterclockwise. You can skip the call to <code>OperatorSimplifyOGC</code>
			if you trust your input polygon.
			<div class="codeSample">
<pre>static List&lt;Polygon&gt; getAllOuterRings(Polygon polygon)
{
  Polygon simplePolygon = (Polygon)OperatorSimplifyOGC.local().execute(polygon, null, true, null);
  ArrayList&lt;Polygon&gt; rings = new ArrayList&lt;Polygon&gt;();
  int n = simplePolygon.getPathCount();
  for (int i = 0; i < n; i++)
  {
    if (simplePolygon.calculateRingArea2D(i) <= 0)
      continue;

    Polygon ring = new Polygon();
    ring.addPath(simplePolygon, i, true);
    rings.add(ring);
  }

  return rings;
}
</pre>
			</div>
			<p>The method <code>getOutermostRings</code> extracts the outermost rings, that is,
			only rings that are not contained inside of any hole.</p>
			<div class="codeSample">
<pre>static List&lt;Polygon&gt; getOutermostRings(Polygon polygon)
{
  List&lt;Polygon&gt; allOuterRings = getAllOuterRings(polygon);
  GeometryCursor outerRingsCursor = new SimpleGeometryCursor(allOuterRings);
  GeometryCursor unionCursor = OperatorUnion.local().execute(outerRingsCursor, null, null);
  Geometry unionPoly = unionCursor.next();

  <span class="codeComment">// Holes could have been produced during the union, so rerun just in case.</span>
  return getAllOuterRings((Polygon)unionPoly);
}
</pre>
			</div>
			<br /><br />
		</div>
	</body>
</html>
